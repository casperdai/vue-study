##### 全局component，directive，filter是如何实现的？

以component为例

```
src/core/global-api/assets.js
ASSET_TYPES.forEach(type => {
  Vue[type] = function (
    id: string,
    definition: Function | Object
  ): Function | Object | void {
    if (!definition) {
      return this.options[type + 's'][id]
    } else {
      ...

      this.options[type + 's'][id] = definition
      return definition
    }
  }
})
```

根据源码，component均存放在构造函数的options.compoents中

```
src/core/global-api/extend.js
...
Sub.options = mergeOptions(
  Super.options,
  extendOptions
)
...

src/core/util/options.js
function mergeAssets (
  parentVal: ?Object,
  childVal: ?Object,
  vm?: Component,
  key: string
): Object {
  const res = Object.create(parentVal || null)
  if (childVal) {
    process.env.NODE_ENV !== 'production' && assertObjectType(key, childVal, vm)
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets
})
```

通过Ctor.extend生成新构造函数时，options.compoents是以Ctor.options.compoents为原型构造

```
src/core/instance/init.js
...
if (options && options._isComponent) {
  initInternalComponent(vm, options)
} else {
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
  )
}
...

export function initInternalComponent (vm: Component, options: InternalComponentOptions) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  ...
}
```

实例的$options属性要么是以构造函数的options为原型构造要么通过mergeOptions合并后生成

```
component -> $options.components[component] -> Ctor.options.components[component] -> SuperCtor.options.components[component]
```

固查找时根据类型先获取对应类型的字典，然后从字典中通过关键字查询，层层查询后最终会定位至构造函数上options中，以此实现全局注册

##### v-if和v-for优先级谁高，为什么不提倡一起用？

```
src/compiler/codegen/index.js
export function genElement (el: ASTElement, state: CodegenState): string {
  ...
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    ...
  }
}
```

根据源码，生成render函数时优先v-for再解析v-if，固即使v-if不成立时也会进行v-for的循环调用

##### 响应式中Observe实例中存有dep，defineReactive中也有dep，为什么会有2个？

defineReactive中的dep是在对象本身进行赋值时进行触发通知，例如{ name: val }当name发生赋值时将进行通知

但当val为数组时进行push等操作或者为对象时进行set或del操作时自身未进行赋值操作，这时将通过Observe实例进行触发通知

##### 为什么\<Componet scroll-x/>可以获取scrollX为true？

源码中若prop定义的type包含Boolean类型，则当key === '' || key === value时，type未包含String或String的优先级在Boolean后时将转换为true

##### props，componets、directives和filters命名最佳实践？

小驼峰

```
const camelizeRE = /-(\w)/g
export const camelize = cached((str: string): string => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '')
})
```

大驼峰（pascal）

```
export const capitalize = cached((str: string): string => {
  return str.charAt(0).toUpperCase() + str.slice(1)
})
```

横线连接（kebab-case）

```
const hyphenateRE = /\B([A-Z])/g
export const hyphenate = cached((str: string): string => {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
})
```

解析props获取关键字后会调用camelize进行转换，最佳实践为小驼峰命名

componets、directives和filters匹配时，先直接匹配，然后调用camelize转换关键词进行匹配，最后再调用capitalize转换关键字进行匹配，最佳实践为大驼峰或使用和定义均为横线连接

